{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-11-10T07:15:12.000Z","updated":"2019-11-10T07:15:12.492Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-11-10T07:15:32.000Z","updated":"2019-11-10T07:15:32.683Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-11-10T07:15:25.000Z","updated":"2019-11-10T07:15:25.961Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-11-10T07:15:19.000Z","updated":"2019-11-10T07:15:19.381Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"gallery","date":"2019-03-30T11:25:34.000Z","updated":"2019-11-10T11:56:33.993Z","comments":true,"path":"gallery/index.html","permalink":"http://yoursite.com/gallery/index.html","excerpt":"","text":""}],"posts":[{"title":"的实现原理","slug":"的实现原理","date":"2019-11-10T12:15:25.000Z","updated":"2019-11-10T12:15:25.143Z","comments":true,"path":"2019/11/10/的实现原理/","link":"","permalink":"http://yoursite.com/2019/11/10/%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"深入Java 集合学习系列(一)：HashMap 的实现原理","slug":"深入Java-集合学习系列-一-：HashMap-的实现原理","date":"2019-11-09T05:10:51.000Z","updated":"2019-11-10T11:50:14.837Z","comments":true,"path":"2019/11/09/深入Java-集合学习系列-一-：HashMap-的实现原理/","link":"","permalink":"http://yoursite.com/2019/11/09/%E6%B7%B1%E5%85%A5Java-%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97-%E4%B8%80-%EF%BC%9AHashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"1. HashMap 概述：HashMap 是基于哈希表的 Map 接口的非同步实现。此实现提供所有可选的映射操作，并允许使用 null 值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 2. HashMap 的数据结构：在 java 编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap 也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。从上图中可以看出，HashMap 底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个 HashMap 的时候，就会初始化一个数组。 源码如下：123456789101112131. /**2. * The table, resized as necessary. Length MUST Always be a power of two.3. */4. transient Entry[] table;5.6. static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;7. final K key;8. V value;9. Entry&lt;K,V&gt; next;10. final int hash;11. ……12. &#125; 3. HashMap 的存取实现：1) 存储：123456789101112131415161718192021222324251. public V put(K key, V value) &#123;2. // HashMap 允许存放 null 键和 null 值。3. // 当 key 为 null 时，调用 putForNullKey 方法，将 value 放置在数组第一个位置。4. if (key == null)5. return putForNullKey(value);6. // 根据 key 的 keyCode 重新计算 hash 值。7. int hash = hash(key.hashCode());8. // 搜索指定 hash 值在对应 table 中的索引。9. int i = indexFor(hash, table.length);10. // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。11. for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;12. Object k;13. if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;14. V oldValue = e.value;15. e.value = value;16. e.recordAccess(this);17. return oldValue;18. &#125;19. &#125;20. // 如果 i 索引处的 Entry 为 null，表明此处还没有 Entry。21. modCount++;22. // 将 key、value 添加到 i 索引处。23. addEntry(hash, key, value, i);24. return null;25. &#125; 从上面的源代码中可以看出：当我们往 HashMap 中 put 元素的时候，先根据 key 的hashCode 重新计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。addEntry(hash, key, value, i)方法根据计算出的 hash 值，将 key-value对放在数组 table的 i索引处。addEntry是HashMap提供的一个包访问权限的方法，代码如下：12345678910111. void addEntry(int hash, K key, V value, int bucketIndex) &#123;2. // 获取指定 bucketIndex 索引处的 Entry3. Entry&lt;K,V&gt; e = table[bucketIndex];4. // 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry5. table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);6. // 如果 Map 中的 key-value 对的数量超过了极限7. if (size++ &gt;= threshold)8. // 把 table 对象的长度扩充到原来的 2 倍。9. resize(2 * table.length);10. &#125; 当系统决定存储 HashMap 中的 key-value 对时，完全没有考虑 Entry 中的 value，仅仅只是根据 key来计算并决定每个 Entry的存储位置。我们完全可以把 Map 集合中的 value 当 成 key 的附属，当系统决定了 key 的存储位置之后，value 随之保存在那里即可。 hash(int h)方法根据 key 的 hashCode重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的 hash 冲突。 Java 代码12341. static int hash(int h) &#123;2. h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);3. return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);4. &#125; 我们可以看到在 HashMap 中要找到某个元素，需要根据 key 的 hash 值来求得对应数组中的位置。如何计算这个位置就是 hash 算法。前面说过 HashMap 的数据结构是数组和链表的结合，所以我们当然希望这个 HashMap 里面的 元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用 hash 算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表，这样就大大优化了查询的效率。 对于任意给定的对象，只要它的 hashCode() 返回值相同，那么程序调用 hash(int h) 方法所计算得到的 hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，在 HashMap 中是这样做的：调用indexFor(inth,intlength)方法来计算该对象应该保存在 table 数组的哪个索引处。indexFor(int h, int length) 方法的代码如下： Java 代码1231. static int indexFor(int h, int length) &#123;2. return h &amp; (length-1);3. &#125; 这个方法非常巧妙，它通过 h &amp; (table.length -1) 来得到该对象的保存位，而 HashMap底层数组的长度总是 2 的 n 次方，这是 HashMap 在速度上的优化。在HashMap 构造器中有如下代码： Java 代码1231. int capacity = 1;2. while (capacity &lt; initialCapacity)3. capacity &lt;&lt;= 1; 这段代码保证初始化时 HashMap 的容量总是 2 的 n 次方，即底层数组的长度总是为 2 的 n 次方。当 length 总是 2 的 n 次方时，h&amp; (length-1)运算等价于对 length 取模，也就是h%length，但是&amp;比%具有更高的效率。这看上去很简单，其实比较有玄机的，我们举个例子来说明： 从上面的例子中可以看出：当它们和 15-1（1110）“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8 和 9 会被放到数组中的同一个位置上形成链表，那么查询的时候就需要遍历这个链 表，得到 8 或者 9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为 15 的时候，hash 值会与 15-1 （1110）进行“与”，那么 最后一位永远是 0，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！而当数组长度为 16 时，即为 2 的 n 次方时，2n-1 得到的二进制数的每个位上的值都为 1，这使得在低位上&amp;时，得到的和原hash的低位相同，加之hash(int h)方法对key的hashCode的进一步优化，加入了高位计算，就使得只有相同的 hash 值的两个值才会被放到数组中的同一个位置上形成链表。所以说，当数组长度为 2 的 n 次幂的时候，不同的 key 算得得 index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。根据上面 put 方法的源代码可以看出，当程序试图将一个 key-value 对放入 HashMap中时，程序首先根据该 key 的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry 的 value，但 key 不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位 于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。4. HashMap 的 resize（rehash）：1234567891011121314151617void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; boolean oldAltHashing = useAltHashing; useAltHashing |= sun.misc.VM.isBooted() &amp;&amp; (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD); boolean rehash = oldAltHashing ^ useAltHashing; transfer(newTable, rehash); table = newTable; threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1); &#125; 当 HashMap 中的元素越来越多的时候，hash 冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对 HashMap 的数组进行扩容，数组扩容这个操作也会出现在 ArrayList 中，这是一个常用的操作，而在 HashMap 数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是 resize。 么 HashMap 什么时候进行扩容呢？当 HashMap 中的元素个数超过数组大小loadFactor 时，就会进行数组扩容，loadFactor 的默认值为 0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为 16，那么当 HashMap 中元素个数超过 160.75=12的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知 HashMap 中元素的个数，那么预设元素的个数能够有效的提高 HashMap 的性能。 5. HashMap 的性能参数：HashMap 包含如下几个构造器：HashMap(int initialCapacity, float loadFactor)：以指定初始容量、指定的负载因子创建一个 HashMap。12345678910111213141516171819202122public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); // Find a power of 2 &gt;= initialCapacity int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; this.loadFactor = loadFactor; threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1); table = new Entry[capacity]; useAltHashing = sun.misc.VM.isBooted() &amp;&amp; (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD); init(); &#125; HashMap(int initialCapacity)：构建一个初始容量为 initialCapacity，负载因子为 0.75 的 HashMap。123public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; HashMap()：构建一个初始容量为 16，负载因子为 0.75 的 HashMap。123public HashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR); &#125; loadFactor：负载因子 loadFactor 定义为：散列表的实际元素数目(n)/ 散列表的容量(m)。负载因子衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是 O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。 HashMap 的实现中，通过 threshold 字段来判断 HashMap 的最大容量： Java 代码11. threshold = (int)(capacity * loadFactor); 结合负载因子的定义公式可知，threshold 就是在此 loadFactor 和 capacity 对应下允许的最大元素数目，超过这个数目就重新 resize，以降低实际的负载因子。默认的的负载因子0.75是对空间和时间效率的一个平衡选择。当容量超出此最大容量时，resize后的HashMap容量是容量的两倍： Java 代码121. if (size++ &gt;= threshold)2. resize(2 * table.length);","categories":[],"tags":[]},{"title":"集合之Map接口","slug":"集合之Map接口","date":"2019-11-03T07:53:01.000Z","updated":"2019-11-03T07:55:50.179Z","comments":true,"path":"2019/11/03/集合之Map接口/","link":"","permalink":"http://yoursite.com/2019/11/03/%E9%9B%86%E5%90%88%E4%B9%8BMap%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"Map接口 Map接口概述1.Map与Collection并列存在。用于保存具有映射关系的数据:key-value2.Map 中的 key 和 value 都可以是任何引用类型的数据3.Map 中的 key 用Set来存放，不允许重复，即同一个 Map 对象所对应的类，须重写hashCode()和equals()方法4.常用String类作为Map的“键”5.key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value6.Map接口的常用实现类：HashMap、TreeMap、LinkedHashMap和Properties。其中，HashMap是 Map 接口使用频率最高的实现类 Map接口：常用方法 Map实现类之一：HashMap Map实现类之三：TreeMap 自然排序（Comparable接口） 定制排序（Comparator()） Collections工具类 Collections常用方法","categories":[],"tags":[]},{"title":"集合之Set接口","slug":"集合之Set接口","date":"2019-11-03T07:52:34.000Z","updated":"2019-11-09T05:09:30.389Z","comments":true,"path":"2019/11/03/集合之Set接口/","link":"","permalink":"http://yoursite.com/2019/11/03/%E9%9B%86%E5%90%88%E4%B9%8BSet%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"Collection子接口之二： Set接口Set 接口概述123Set接口是Collection的子接口，set接口没有提供额外的方法 Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个 Set 集合中，则添加操作失败。 Set 判断两个对象是否相同不是使用 == 运算符，而是根据equals() 方法 Set实现类之一：HashSetHashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。HashSet 按 Hash算法来存储集合中的元素，因此具有很好的存取、查找、删除 性能。 HashSet 具有以下特点：不能保证元素的排列顺序 HashSet 不是线程安全的 集合元素可以是 null ==HashSet 集合判断两个元素相等的标准==：两个对象通过hashCode() 方法比较相等，并且两个对象的equals()方法返回值也相等。 对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Objectobj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。Set实现类之一：HashSet向HashSet中添加元素的过程：当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法 来得到该对象的 hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对象 在 HashSet 底层数组中的存储位置。（这个散列函数会与底层数组的长度相计算得到在 数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布， 该散列函数设计的越好） 如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果 为true，添加失败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了， 那么会通过链表的方式继续链接。 如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相 等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功。 Set实现类之三：TreeSetTreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态 。TreeSet底层使用红黑树结构存储数据。新增的方法如下： (了解)TreeSet 两种排序方法：自然排序和定制排序。默认情况下，TreeSet采用自然排序。 再具体就不说了，可以参看http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html，对红黑树的讲解写得不错。排 序—自然排序自然排序：TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口。12345678910111213实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过compareTo(Object obj) 方法的返回值来比较大小。向 TreeSet 中添加元素时，只有第一个元素无须比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较。 因为只有相同类的两个实例才会比较大小，所以向 TreeSet 中添加的应该是同一个类的对象。 对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较返回值。 当需要把一个对象放入 TreeSet 中，重写该对象对应的 equals() 方法时，应保证该方法与 compareTo(Object obj) 方法有一致的结果：如果两个对象通过equals() 方法比较返回 true，则通过 compareTo(Object obj) 方法比较应返回 0。否则，让人难以理解。 排 序—定制排序1234567891011TreeSet的自然排序要求元素所属的类实现Comparable接口，如果元素所属的类没有实现Comparable接口，或不希望按照升序(默认情况)的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。定制排序，通过Comparator接口来实现。需要重写compare(T o1,T o2)方法。 利用int compare(T o1,To2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。 要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。 此时，仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异常。 使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0 ==核心讲解：remove()方法通过元素的哈希值来判断位置== ==add()方法添加元素，手下比较哈希值，然后是equals()方法==","categories":[],"tags":[]},{"title":"集合之Collection接口","slug":"集合之Collection接口","date":"2019-11-03T07:52:24.000Z","updated":"2019-11-03T07:54:34.589Z","comments":true,"path":"2019/11/03/集合之Collection接口/","link":"","permalink":"http://yoursite.com/2019/11/03/%E9%9B%86%E5%90%88%E4%B9%8BCollection%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"Java 集合框架概述一方面， 面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储。另一方面，使用Array存储对象方面具有一些弊端，而Java 集合就像一种容器，可以动态地把多个对象的引用放入容器中。 数组在内存存储方面的特点：数组初始化以后，长度就确定了。 数组声明的类型，就决定了进行元素初始化时的类型数组在存储数据方面的弊端：数组初始化以后，长度就不可变了，不便于扩展 数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高。同时无法直接获取存储元素的个数 数组存储的数据是有序的、可以重复的。----&gt;存储数据的特点单一 Java 集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组。 使用场景 Java 集合可分为 Collection 和 Map 两种体系Collection接口：单列数据，定义了存取一组对象的方法的集合List：元素有序、可重复的集合 Set：元素无序、不可重复的集合Map接口：双列数据，保存具有映射关系“key-value对”的集合Collection接口继承树 Collection接口方法Collection 接口Collection 接口是 List、Set 和 Queue 接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 和 Queue 集合。 JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List)实现。 在 Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都当成 Object 类型处理；从 JDK 5.0 增加了泛型以后，Java 集合可以记住容器中对象的数据类型。 代码演示 Iterator迭代器接口使用 Iterator 接口遍历集合元素Iterator对象称为迭代器(设计模式的一种)，主要用于遍历Collection集合中的元素。 GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。类似于“公交车上的售票员”、“火车上的乘务员”、“空姐”。 Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。 Iterator 仅用于遍历集合，Iterator本身并不提供承装对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合. 集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。Iterator接口的方法 Iterator接口remove()方法 使用 foreach 循环遍历集合元素1.Java 5.0 提供了 foreach 循环迭代访问 Collection和数组。 2.遍历操作不需获取Collection或数组的长度，无需使用索引访问元素。 3.遍历集合的底层调用Iterator完成操作。 4.foreach还可以用来遍历数组。例题123456789public static void main(String[] args) &#123;String[] str = new String[5];for (String myStr : str) &#123;myStr = &quot;atguigu&quot;;System.out.println(myStr);&#125;for (int i = 0; i &lt; str.length; i++) &#123;System.out.println(str[i]);&#125; &#125; Collection子接口之一：List接口List接口概述1.鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组2.list集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。3.List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。4.JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。 List实现类之一：ArrayListArrayList 是 List 接口的典型实现类、主要实现类本质上，ArrayList是对象引用的一个”变长”数组ArrayList的JDK1.8之前与之后的实现区别？JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组 JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元 素时再创建一个始容量为10的数组Arrays.asList(…) 方法返回的 List 集合，既不是 ArrayList 实例，也不是Vector 实例。 Arrays.asList(…) 返回值是一个固定长度的 List 集合 List实现类之二：LinkedListLinkedList：==双向链表==，内部没有声明数组，而是定义了Node类型的first和last，用于记录首末元素。同时，定义内部类Node，作为LinkedList中保存数据的基本结构。Node除了保存数据，还定义了两个变量：prev变量记录前一个元素的位置 next变量记录下一个元素的位置","categories":[],"tags":[]},{"title":"hexo+github博客搭建","slug":"hexo-github博客搭建","date":"2019-11-02T08:54:40.000Z","updated":"2019-11-02T08:55:37.912Z","comments":true,"path":"2019/11/02/hexo-github博客搭建/","link":"","permalink":"http://yoursite.com/2019/11/02/hexo-github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"在官网下载Git和Nodejs按步骤进行安装，一直下一步就ok在命令行检测安装是否成功npm全局安装cnpmcnpm安装完成npm全局安装hexohexo安装完成新建一个blog文件夹（文件夹名随意），并进行博客初始化在命令行界面用cd blog进入到blog文件夹，然后输入hexo init初始化博客注意：如果初始化博客卡住，只需把文件夹内的文件全部删除，然后重新初始化即可创建本地的静态博客页面，可以通过本地端口打开Ctrl+C结束进程 接下就就需要把本地的博客部署到Github的服务器上啦，也是最关键的地方 在电脑左下角的开始界面中打卡最近添加的Git Bash 将用户名设置为自己Github的账户名，之后验证会很重要 设置自己的常用邮箱 之后打开这个网页新建Github账号，Username最好与刚才设置的user.name相同 新建Github帐号之后进行登录，然后新建一个New repository 之后设置Repository name，打码的地方必须都一样 创建Github完成，记住自己的网址 之后在blog文件夹内打开此文件 在文件末尾#Deployment加入以上的内容，在repo处填上网页地址 之后在官网安装GitHub Desktop 安装之后进行登录，输入用户名和密码 之后输入hexo d会报错，因为缺少一个git安装包 然后通过此步骤安装缺少的安装包 安装的时候会出现弹框，登录Github账号就OK了 之后就可以通过域名直接访问自己的博客啦，是不是非常有成就感鸭！ 大家肯定会发现我的博客为何看起来很美观呢？？？ 接下来就教大家如何设置博客主题，让自己的博客变的美观首先先清楚博客本地数据然后进入hexo官网选择自己喜欢的主题小编使用的是Ocean的主题，复制红圈内的链接现在themes文件夹里新建Ocean文件夹，用git clone https:// 刚才复制的链接 themes/ocean（图片里的themes之前没有/，小编打错了）打开此文件将默认主题改为刚才新建的文件夹名称（这里用的是ocean主题）主题更改成功","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"多线程讲解2","slug":"多线程讲解2","date":"2019-11-02T05:26:08.000Z","updated":"2019-11-02T05:27:24.748Z","comments":true,"path":"2019/11/02/多线程讲解2/","link":"","permalink":"http://yoursite.com/2019/11/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%B2%E8%A7%A32/","excerpt":"","text":"线程的生命周期JDK中用Thread.State类定义了线程的几种状态要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的==五种状态：====新建==： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态 ==就绪==：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源 ==运行==：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能 ==阻塞==：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态 ==死亡==：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束 线程的同步（开发重点）问题的提出多个线程执行的不确定性引起执行结果的不稳定多个线程对账本的共享，会造成操作的不完整性，会破坏数据。 例 题模拟火车站售票程序，开启三个窗口售票。 多线程出现了安全问题==2.问题的原因：==当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据的错误。==3. 解决办法：==对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。 Synchronized的使用方法Java对于多线程的安全问题提供了专业的解决方式：同步机制 同步机制中的锁同步锁机制：在《Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。 防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。synchronized的锁是什么？ 任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）。 同步方法的锁：静态方法（类名.class）、非静态方法（this） 同步代码块：自己指定，很多时候也是指定为this或类名.class注意： 必须确保使用同一个资源的==多个线程共用一把锁==，这个非常重要，否则就无法保证共享资源的安全 一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方法共用同一把锁（this），同步代码块（指定需谨慎） 卖票问题接口方式 继承方式 Lock(锁) 从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。 ==java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具==。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。 ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。 synchronized 与 Lock 的对比 Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域自动释放 Lock只有代码块锁，synchronized有代码块锁和方法锁 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）优先使用顺序：Lock—&gt;同步代码块（已经进入了方法体，分配了相应资源）—-&gt; 同步方法（在方法体之外）","categories":[],"tags":[]},{"title":"多线程讲解1","slug":"多线程讲解1","date":"2019-11-02T05:26:03.000Z","updated":"2019-11-02T05:26:38.576Z","comments":true,"path":"2019/11/02/多线程讲解1/","link":"","permalink":"http://yoursite.com/2019/11/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%B2%E8%A7%A31/","excerpt":"","text":"# 基本概念：程序、进程、线程程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。 ==程序(program==)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。 进程(process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期 如：运行中的QQ，运行中的MP3播放器 程序是静态的，进程是动态 进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域 线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径若一个进程同一时间并行执行多个线程，就是支持多线程的 线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小 一个进程中的多个线程共享相同的内存单元/内存地址空间它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。 单核CPU和多核CPU的理解单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果有某个人不想交钱，那么收费人员可以把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费）。但是因为CPU时间单元特别短，因此感觉不出来。 如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的） 一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。 并行与并发并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。 并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。 #### 线程的创建和使用线程的创建和启动Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来体现。 Thread类的特性： 1.每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体 2.通过该Thread对象的start()方法来启动这个线程，而非直接调用run() API中创建线程的两种方式方式一：继承Thread类1) 定义子类继承Thread类。2) 子类中重写Thread类中的run方法。3) 创建Thread子类对象，即创建了线程对象。4) 调用线程对象start方法：启动线程，调用run方法。注意点： 如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。 run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。 想要启动多线程，必须调用start方法。 一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上的异常“IllegalThreadStateException”。 方式二：实现Runnable接口1) 定义子类，实现Runnable接口。2) ==子类中重写Runnable接口中的run方法。==3) 通过Thread类含参构造器创建线程对象。4) ==将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。==5) 调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。 ==比较选择的两种方式==开发中：优先选择：实现Runnable接口的方式区别：继承Thread：线程代码存放Thread子类run方法中。实现Runnable：线程代码存在接口的子类的run方法。原因1.实现的方式没有类的单继承性的的局限2.多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。 创建三个窗口卖票，总票数为100张（两种方式）继承Thread类： 实现Runabble接口： 补充：线程的分类Java中的线程分为两类：一种是==守护线程==，一种是==用户线程==。它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。 守护线程是用来服务用户线程的，通过在start()方法前调用thread.setDaemon(true)可以把一个用户线程变成一个守护线程。 Java垃圾回收就是一个典型的守护线程。 若JVM中都是守护线程，当前JVM将退出。 形象理解：==兔死狗烹，鸟尽弓藏==","categories":[],"tags":[]}]}